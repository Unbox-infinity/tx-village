module Ledger.Sim.Actions (
  lookupUTxO,
  utxosAtAddress,
  submitTx,
  getCurrentSlot,
  getsAppState,
  getAppState,
  setAppState,
  asksAppCtx,
  askAppCtx,
  throwAppError,
  incrementSlot,
  getTxId,
) where

import Data.ByteArray (convert)
import Data.ByteString (ByteString)
import Data.ByteString.Lazy qualified as LBS
import Data.Map.Strict qualified as M
import Data.Maybe (mapMaybe)

import Codec.Serialise (serialise)
import Crypto.Hash (Blake2b_224 (Blake2b_224), hashWith)

import Control.Monad.Except (MonadError (throwError), withExcept)
import Control.Monad.Reader (asks, mapReaderT, withReaderT)
import Control.Monad.State (mapStateT, modify')
import Control.Monad.State.Strict (gets)
import Ledger.Sim.Submission qualified as Submission
import Ledger.Sim.Types.LedgerConfig (LedgerConfig (lc'appCtx))
import Ledger.Sim.Types.LedgerSim (LedgerSim, LedgerSimError (LedgerSimError'Application, LedgerSimError'Submission))
import Ledger.Sim.Types.LedgerState (LedgerState (ls'currentTime, ls'userState, ls'utxos))
import Ledger.Sim.Types.Submission (SubmissionEnv (SubmissionEnv), SubmissionResult (SubmissionResult, submissionResult'EvaluationResults, submissionResult'TxId))
import PlutusLedgerApi.V2 (
  Address,
  POSIXTime (getPOSIXTime),
  TxId (TxId),
  TxInInfo (TxInInfo),
  TxInfo (txInfoId),
  TxOut (txOutAddress),
  TxOutRef,
 )
import PlutusTx.Builtins qualified as PlutusTx

lookupUTxO :: TxOutRef -> LedgerSim ctx st e (Maybe TxOut)
lookupUTxO ref = M.lookup ref <$> gets ls'utxos

utxosAtAddress :: Address -> LedgerSim ctx st e [TxInInfo]
utxosAtAddress addr =
  mapMaybe
    ( \(ref, txOut) ->
        if txOutAddress txOut == addr
          then Just $ TxInInfo ref txOut
          else Nothing
    )
    . M.assocs
    <$> gets ls'utxos

{- Known shortcomings:
- Tx id must be generated and is not generated by hashing the tx body (how it works on the chain).
  This is because we don't have a real Cardano.Api TxBody available at hand and creating one from PLA would
  require a lot of effort.
  As a stopgap, Tx id is generated from current POSIX time. This may violate the assumptions of any scripts that
  use hashing inside them. ex: script that checks `txId txInfo != blake2b_224 time` where time is some time from validity range.
- See: 'checkTx'
-}
submitTx :: TxInfo -> LedgerSim ctx st e SubmissionResult
submitTx txInfo = do
  evaluationResults <-
    withReaderT (SubmissionEnv txInfo) $
      mapReaderT
        (mapStateT (withExcept LedgerSimError'Submission))
        Submission.submit

  pure $
    SubmissionResult
      { submissionResult'TxId = txInfoId txInfo
      , submissionResult'EvaluationResults = evaluationResults
      }

getCurrentSlot :: LedgerSim ctx st e POSIXTime
getCurrentSlot = gets ls'currentTime

-- | Get a specific component of the user state from the ledger, using given projection function.
getsAppState :: (st -> a) -> LedgerSim ctx st e a
getsAppState f = gets $ f . ls'userState

-- | Get the user state from the ledger.
getAppState :: LedgerSim ctx st e st
getAppState = getsAppState id

-- | Set the user state
setAppState :: st -> LedgerSim ctx st e ()
setAppState st = modify' $ \s ->
  s
    { ls'userState = st
    }

-- | Get a specific component of the user state from the ledger, using given projection function.
asksAppCtx :: (ctx -> a) -> LedgerSim ctx st e a
asksAppCtx f = asks $ f . lc'appCtx

-- | Get the user state from the ledger.
askAppCtx :: LedgerSim ctx st e ctx
askAppCtx = asksAppCtx id

-- | Throw custom application error.
throwAppError :: e -> LedgerSim ctx st e a
throwAppError = throwError . LedgerSimError'Application

incrementSlot :: LedgerSim ctx st e ()
incrementSlot =
  modify' $ \st -> st {ls'currentTime = ls'currentTime st + 1}

{- | Generate tx id from time. NOTE: This is simply a stopgap measure used in the simulator. In reality,
tx ids are hashes of a transaction body.
-}
genTxId :: POSIXTime -> TxId
genTxId =
  TxId
    . PlutusTx.toBuiltin
    . convert @_ @ByteString
    . hashWith Blake2b_224
    . LBS.toStrict
    . serialise
    . getPOSIXTime

getTxId :: LedgerSim ctx st e TxId
getTxId = gets $ genTxId . ls'currentTime
